;Program compiled by Great Cow BASIC (0.98.07 RC09 2020-04-20 (Windows 32 bit))
;Need help? See the GCBASIC forums at http://sourceforge.net/projects/gcbasic/forums,
;check the documentation or email w_cholmondeley at users dot sourceforge dot net.

;********************************************************************************

;Set up the assembler options (Chip type, clock source, other bits and pieces)
 LIST p=18F25K42, r=DEC
#include <P18F25K42.inc>
 CONFIG CP = OFF, LVP = OFF, WRTD = OFF, WDTE = OFF, XINST = OFF, MVECEN = OFF, MCLRE = EXTMCLR, CLKOUTEN = OFF, RSTOSC = HFINTOSC_1MHZ, FEXTOSC = OFF

;********************************************************************************

;Set aside memory locations for variables
ADDRESS	EQU	10
COMPORT	EQU	11
DELAYTEMP	EQU	0
DELAYTEMP2	EQU	1
DEVICEID	EQU	12
DISPLAYNEWLINE	EQU	13
HEX	EQU	2013
HI2C2ACKPOLLSTATE	EQU	14
HI2C2CON1	EQU	15
HI2C2CON1DEFAULT	EQU	16
HI2C2CURRENTMODE	EQU	17
HI2C2LASTERROR	EQU	18
HI2C2STATEMACHINE	EQU	19
HI2C2WAITMSSPTIMEOUT	EQU	20
HSERPRINTCRLFCOUNT	EQU	21
I2C2BYTE	EQU	22
PRINTLEN	EQU	23
SERDATA	EQU	24
STRINGPOINTER	EQU	25
SYSBYTETEMPA	EQU	5
SYSBYTETEMPB	EQU	9
SYSBYTETEMPX	EQU	0
SYSCALCTEMPA	EQU	5
SYSDIVLOOP	EQU	4
SYSPRINTDATAHANDLER	EQU	26
SYSPRINTDATAHANDLER_H	EQU	27
SYSPRINTTEMP	EQU	28
SYSREPEATTEMP1	EQU	29
SYSSTRINGA	EQU	7
SYSSTRINGA_H	EQU	8
SYSSTRINGLENGTH	EQU	6
SYSSTRINGPARAM1	EQU	2017
SYSSTRINGTEMP	EQU	30
SYSTEMP1	EQU	31
SYSVALTEMP	EQU	32
SYSWAITTEMPMS	EQU	2
SYSWAITTEMPMS_H	EQU	3
SYSWAITTEMPS	EQU	4
SYSWAITTEMPUS	EQU	5
SYSWAITTEMPUS_H	EQU	6

;********************************************************************************

;Alias variables
AFSR0	EQU	16361
AFSR0_H	EQU	16362
SYSHEX_0	EQU	2013
SYSHEX_1	EQU	2014
SYSHEX_2	EQU	2015

;********************************************************************************

;Vectors
	ORG	0
	goto	BASPROGRAMSTART
	ORG	8
	retfie

;********************************************************************************

;Start of program memory page 0
	ORG	12
BASPROGRAMSTART
;Call initialisation routines
	rcall	INITSYS
	rcall	INITPPS
	rcall	INITUSART
	rcall	HI2C2INIT

;Start of the main program
;''
;''  This demonstration shows the I2C2 devices attached the microcontroller, this program support the Microchip I2C2 module.
;''
;''  I2C device required a data bus and a clock bus, devices also required an input voltage and 0v.
;''  I2C2 data bus is connected to PortB.2
;''  I2C2 clock bus is connected to PortB.1
;''  Serial output is connected, as previously, to PortC.6
;''
;''  Connect your I2C2 devices and see the results on the serial terminal.
;''
;''************************************************************************
;''@author  BillR
;''@licence GPL
;''@version 1.00
;''@date    05.05.2020
;----- Configuration
;Chip Settings.
;Generated by PIC PPS Tool for Great Cow Basic
;PPS Tool version: 0.0.6.1
;PinManager data: v1.79.0
;Generated for 18f25k42
;#define PPSToolPart 18f25k42
;#Define HI2C2_CLOCK PORTB.1    'Define a constant
;#Define HI2C2_DATA PORTB.2    'Define a constant
;Setup Serial port
;#DEFINE USART_BAUD_RATE 9600
;#DEFINE USART_TX_BLOCKING
;Define I2C settings
;#DEFINE HI2C2_BAUD_RATE 125
;#DEFINE HI2C2_DATA PORTB.2   (See Sub INITPPPS)
;#DEFINE HI2C2_CLOCK PORTB.1  (See Sub INITPPS)
;For this solution we can set the TSCL period to Zero as the Stop condition must be held for TSCL after Stop transition
;#define HI2C2ITSCLWaitPeriod 0
;*****************************************************************************************************
;Main program commences here.. everything before this is setup for the board.
;Dim DeviceID As Byte
;Dim DISPLAYNEWLINE As Byte
;Do
SysDoLoop_S1
;HSerPrintCRLF
	movlw	1
	movwf	HSERPRINTCRLFCOUNT,ACCESS
	movlw	1
	movwf	COMPORT,ACCESS
	rcall	HSERPRINTCRLF
;HSerPrint "--- Hardware I2C2 --- "
	lfsr	1,SYSSTRINGPARAM1
	movlw	low StringTable1
	movwf	TBLPTRL,ACCESS
	movlw	high StringTable1
	movwf	TBLPTRH,ACCESS
	rcall	SysReadString
	movlw	low SYSSTRINGPARAM1
	movwf	SysPRINTDATAHandler,ACCESS
	movlw	high SYSSTRINGPARAM1
	movwf	SysPRINTDATAHandler_H,ACCESS
	movlw	1
	movwf	COMPORT,ACCESS
	rcall	HSERPRINT274
;HSerPrintCRLF 2
	movlw	2
	movwf	HSERPRINTCRLFCOUNT,ACCESS
	movlw	1
	movwf	COMPORT,ACCESS
	rcall	HSERPRINTCRLF
;Now assumes Serial Terminal is operational
;HSerPrintCRLF
	movlw	1
	movwf	HSERPRINTCRLFCOUNT,ACCESS
	movlw	1
	movwf	COMPORT,ACCESS
	rcall	HSERPRINTCRLF
;HSerPrint "   "
	lfsr	1,SYSSTRINGPARAM1
	movlw	low StringTable2
	movwf	TBLPTRL,ACCESS
	movlw	high StringTable2
	movwf	TBLPTRH,ACCESS
	rcall	SysReadString
	movlw	low SYSSTRINGPARAM1
	movwf	SysPRINTDATAHandler,ACCESS
	movlw	high SYSSTRINGPARAM1
	movwf	SysPRINTDATAHandler_H,ACCESS
	movlw	1
	movwf	COMPORT,ACCESS
	rcall	HSERPRINT274
;Create a horizontal row of numbers
;For DeviceID = 0 To 15
	setf	DEVICEID,ACCESS
SysForLoop1
	incf	DEVICEID,F,ACCESS
;HSerPrint Hex(deviceID)
	movff	DEVICEID,SYSVALTEMP
	rcall	FN_HEX
	movlw	low HEX
	movwf	SysPRINTDATAHandler,ACCESS
	movlw	high HEX
	movwf	SysPRINTDATAHandler_H,ACCESS
	movlw	1
	movwf	COMPORT,ACCESS
	rcall	HSERPRINT274
;HSerPrint " "
	lfsr	1,SYSSTRINGPARAM1
	movlw	low StringTable3
	movwf	TBLPTRL,ACCESS
	movlw	high StringTable3
	movwf	TBLPTRH,ACCESS
	rcall	SysReadString
	movlw	low SYSSTRINGPARAM1
	movwf	SysPRINTDATAHandler,ACCESS
	movlw	high SYSSTRINGPARAM1
	movwf	SysPRINTDATAHandler_H,ACCESS
	movlw	1
	movwf	COMPORT,ACCESS
	rcall	HSERPRINT274
;Next
	movlw	15
	subwf	DEVICEID,W,ACCESS
	btfss	STATUS, C,ACCESS
	bra	SysForLoop1
SysForLoopEnd1
;Create a vertical column of numbers
;For DeviceID = 0 To 255
	setf	DEVICEID,ACCESS
SysForLoop2
	incf	DEVICEID,F,ACCESS
;DisplayNewLine = DeviceID % 16
	movff	DEVICEID,SysBYTETempA
	movlw	16
	movwf	SysBYTETempB,ACCESS
	rcall	SysDivSub
	movff	SysBYTETempX,DISPLAYNEWLINE
;If DisplayNewLine = 0 Then
	movf	DISPLAYNEWLINE,F,ACCESS
	btfss	STATUS, Z,ACCESS
	bra	ENDIF2
;HSerPrintCRLF
	movlw	1
	movwf	HSERPRINTCRLFCOUNT,ACCESS
	movlw	1
	movwf	COMPORT,ACCESS
	rcall	HSERPRINTCRLF
;HSerPrint Hex(DeviceID)
	movff	DEVICEID,SYSVALTEMP
	rcall	FN_HEX
	movlw	low HEX
	movwf	SysPRINTDATAHandler,ACCESS
	movlw	high HEX
	movwf	SysPRINTDATAHandler_H,ACCESS
	movlw	1
	movwf	COMPORT,ACCESS
	rcall	HSERPRINT274
;If DisplayNewLine > 0 Then
	movf	DISPLAYNEWLINE,W,ACCESS
	sublw	0
	btfsc	STATUS, C,ACCESS
	bra	ENDIF5
;HSerPrint " "
	lfsr	1,SYSSTRINGPARAM1
	movlw	low StringTable3
	movwf	TBLPTRL,ACCESS
	movlw	high StringTable3
	movwf	TBLPTRH,ACCESS
	rcall	SysReadString
	movlw	low SYSSTRINGPARAM1
	movwf	SysPRINTDATAHandler,ACCESS
	movlw	high SYSSTRINGPARAM1
	movwf	SysPRINTDATAHandler_H,ACCESS
	movlw	1
	movwf	COMPORT,ACCESS
	rcall	HSERPRINT274
;End If
ENDIF5
;End If
ENDIF2
;HSerPrint " "
	lfsr	1,SYSSTRINGPARAM1
	movlw	low StringTable3
	movwf	TBLPTRL,ACCESS
	movlw	high StringTable3
	movwf	TBLPTRH,ACCESS
	rcall	SysReadString
	movlw	low SYSSTRINGPARAM1
	movwf	SysPRINTDATAHandler,ACCESS
	movlw	high SYSSTRINGPARAM1
	movwf	SysPRINTDATAHandler_H,ACCESS
	movlw	1
	movwf	COMPORT,ACCESS
	rcall	HSERPRINT274
;Do an initial Start
;SI2C2Discovery ( DeviceID )
	movff	DEVICEID,ADDRESS
	rcall	SI2C2DISCOVERY
	movff	ADDRESS,DEVICEID
;If HI2C2WaitMSSPTimeout <> TRUE Then
	incf	HI2C2WAITMSSPTIMEOUT,W,ACCESS
	btfsc	STATUS, Z,ACCESS
	bra	ELSE3_1
;Did device fail to respond?
;If HI2C2AckpollState = FALSE Then
	movf	HI2C2ACKPOLLSTATE,F,ACCESS
	btfss	STATUS, Z,ACCESS
	bra	ELSE6_1
;HSerPrint   Hex(deviceID)
	movff	DEVICEID,SYSVALTEMP
	rcall	FN_HEX
	movlw	low HEX
	movwf	SysPRINTDATAHandler,ACCESS
	movlw	high HEX
	movwf	SysPRINTDATAHandler_H,ACCESS
	movlw	1
	movwf	COMPORT,ACCESS
	rcall	HSERPRINT274
;Else
	bra	ENDIF6
ELSE6_1
;HSerPrint "--"
	lfsr	1,SYSSTRINGPARAM1
	movlw	low StringTable4
	movwf	TBLPTRL,ACCESS
	movlw	high StringTable4
	movwf	TBLPTRH,ACCESS
	rcall	SysReadString
	movlw	low SYSSTRINGPARAM1
	movwf	SysPRINTDATAHandler,ACCESS
	movlw	high SYSSTRINGPARAM1
	movwf	SysPRINTDATAHandler_H,ACCESS
	movlw	1
	movwf	COMPORT,ACCESS
	rcall	HSERPRINT274
;End If
ENDIF6
;Do a stop.
;Else
	bra	ENDIF3
ELSE3_1
;HSerPrint "! "
	lfsr	1,SYSSTRINGPARAM1
	movlw	low StringTable5
	movwf	TBLPTRL,ACCESS
	movlw	high StringTable5
	movwf	TBLPTRH,ACCESS
	rcall	SysReadString
	movlw	low SYSSTRINGPARAM1
	movwf	SysPRINTDATAHandler,ACCESS
	movlw	high SYSSTRINGPARAM1
	movwf	SysPRINTDATAHandler_H,ACCESS
	movlw	1
	movwf	COMPORT,ACCESS
	rcall	HSERPRINT274
;End If
ENDIF3
;Next
	movlw	255
	subwf	DEVICEID,W,ACCESS
	btfss	STATUS, C,ACCESS
	bra	SysForLoop2
SysForLoopEnd2
;HSerPrintCRLF 2
	movlw	2
	movwf	HSERPRINTCRLFCOUNT,ACCESS
	movlw	1
	movwf	COMPORT,ACCESS
	rcall	HSERPRINTCRLF
;HSerPrint   "End of Search"
	lfsr	1,SYSSTRINGPARAM1
	movlw	low StringTable6
	movwf	TBLPTRL,ACCESS
	movlw	high StringTable6
	movwf	TBLPTRH,ACCESS
	rcall	SysReadString
	movlw	low SYSSTRINGPARAM1
	movwf	SysPRINTDATAHandler,ACCESS
	movlw	high SYSSTRINGPARAM1
	movwf	SysPRINTDATAHandler_H,ACCESS
	movlw	1
	movwf	COMPORT,ACCESS
	rcall	HSERPRINT274
;HSerPrintCRLF 2
	movlw	2
	movwf	HSERPRINTCRLFCOUNT,ACCESS
	movlw	1
	movwf	COMPORT,ACCESS
	rcall	HSERPRINTCRLF
;HSerprint "Test Will Restart in 5 Seconds"
	lfsr	1,SYSSTRINGPARAM1
	movlw	low StringTable7
	movwf	TBLPTRL,ACCESS
	movlw	high StringTable7
	movwf	TBLPTRH,ACCESS
	rcall	SysReadString
	movlw	low SYSSTRINGPARAM1
	movwf	SysPRINTDATAHandler,ACCESS
	movlw	high SYSSTRINGPARAM1
	movwf	SysPRINTDATAHandler_H,ACCESS
	movlw	1
	movwf	COMPORT,ACCESS
	rcall	HSERPRINT274
;HserprintCRLF 2
	movlw	2
	movwf	HSERPRINTCRLFCOUNT,ACCESS
	movlw	1
	movwf	COMPORT,ACCESS
	rcall	HSERPRINTCRLF
;Wait 5 s
	movlw	5
	movwf	SysWaitTempS,ACCESS
	rcall	Delay_S
;Loop
	bra	SysDoLoop_S1
SysDoLoop_E1
;----- Support methods.  Subroutines and Functions
;NONE
BASPROGRAMEND
	sleep
	bra	BASPROGRAMEND

;********************************************************************************

Delay_MS
	incf	SysWaitTempMS_H, F,ACCESS
DMS_START
	movlw	129
	movwf	DELAYTEMP2,ACCESS
DMS_OUTER
	movlw	40
	movwf	DELAYTEMP,ACCESS
DMS_INNER
	decfsz	DELAYTEMP, F,ACCESS
	bra	DMS_INNER
	decfsz	DELAYTEMP2, F,ACCESS
	bra	DMS_OUTER
	decfsz	SysWaitTempMS, F,ACCESS
	bra	DMS_START
	decfsz	SysWaitTempMS_H, F,ACCESS
	bra	DMS_START
	return

;********************************************************************************

Delay_S
DS_START
	movlw	232
	movwf	SysWaitTempMS,ACCESS
	movlw	3
	movwf	SysWaitTempMS_H,ACCESS
	rcall	Delay_MS
	decfsz	SysWaitTempS, F,ACCESS
	bra	DS_START
	return

;********************************************************************************

;Source: string.h (335)
FN_HEX
;Hex(0) = 2
	movlw	2
	banksel	SYSHEX_0
	movwf	SYSHEX_0,BANKED
;Low nibble
;SysStringTemp = SysValTemp And 0x0F
	movlw	15
	andwf	SYSVALTEMP,W,ACCESS
	banksel	SYSSTRINGTEMP
	movwf	SYSSTRINGTEMP,BANKED
;If SysStringTemp > 9 Then SysStringTemp = SysStringTemp + 7
	sublw	9
	btfsc	STATUS, C,ACCESS
	bra	ENDIF7
	movlw	7
	addwf	SYSSTRINGTEMP,F,BANKED
ENDIF7
;Hex(2) = SysStringTemp + 48
	movlw	48
	addwf	SYSSTRINGTEMP,W,BANKED
	banksel	SYSHEX_2
	movwf	SYSHEX_2,BANKED
;Get high nibble
;For SysStringTemp = 1 to 4
	banksel	SYSSTRINGTEMP
	clrf	SYSSTRINGTEMP,BANKED
SysForLoop3
	incf	SYSSTRINGTEMP,F,BANKED
;Rotate SysValTemp Right
	rrcf	SYSVALTEMP,F,ACCESS
;Next
	movlw	4
	subwf	SYSSTRINGTEMP,W,BANKED
	btfss	STATUS, C,ACCESS
	bra	SysForLoop3
SysForLoopEnd3
;SysStringTemp = SysValTemp And 0x0F
	movlw	15
	andwf	SYSVALTEMP,W,ACCESS
	movwf	SYSSTRINGTEMP,BANKED
;If SysStringTemp > 9 Then SysStringTemp = SysStringTemp + 7
	sublw	9
	btfsc	STATUS, C,ACCESS
	bra	ENDIF9
	movlw	7
	addwf	SYSSTRINGTEMP,F,BANKED
ENDIF9
;Hex(1) = SysStringTemp + 48
	movlw	48
	addwf	SYSSTRINGTEMP,W,BANKED
	banksel	SYSHEX_1
	movwf	SYSHEX_1,BANKED
	banksel	0
	return

;********************************************************************************

;Source: hwi2c2.h (379)
HI2C2INIT
;HI2C2CurrentMode = 0
	clrf	HI2C2CURRENTMODE,ACCESS
;Initialise the I2C module
;SI2C2Init
	bra	SI2C2INIT

;********************************************************************************

;Overloaded signature: STRING:byte:, Source: usart.h (1295)
HSERPRINT274
;PrintLen = PrintData(0)
	movffl	SysPRINTDATAHandler,AFSR0
	movffl	SysPRINTDATAHandler_H,AFSR0_H
	movffl	INDF0,PRINTLEN
;If PrintLen <> 0 then
	movf	PRINTLEN,F,ACCESS
	btfsc	STATUS, Z,ACCESS
	bra	ENDIF10
;Write Data
;for SysPrintTemp = 1 to PrintLen
	clrf	SYSPRINTTEMP,ACCESS
	movlw	1
	subwf	PRINTLEN,W,ACCESS
	btfss	STATUS, C,ACCESS
	bra	SysForLoopEnd4
SysForLoop4
	incf	SYSPRINTTEMP,F,ACCESS
;HSerSend(PrintData(SysPrintTemp),comport )
	movf	SYSPRINTTEMP,W,ACCESS
	addwf	SysPRINTDATAHandler,W,ACCESS
	movwf	AFSR0,ACCESS
	movlw	0
	addwfc	SysPRINTDATAHandler_H,W,ACCESS
	movwf	AFSR0_H,ACCESS
	movffl	INDF0,SERDATA
	rcall	HSERSEND264
;next
	movf	PRINTLEN,W,ACCESS
	subwf	SYSPRINTTEMP,W,ACCESS
	btfss	STATUS, C,ACCESS
	bra	SysForLoop4
SysForLoopEnd4
;End If
ENDIF10
;CR
	return

;********************************************************************************

;Source: usart.h (1447)
HSERPRINTCRLF
;repeat HSerPrintCRLFCount
	movff	HSERPRINTCRLFCOUNT,SysRepeatTemp1
	movf	SYSREPEATTEMP1,F,ACCESS
	btfsc	STATUS, Z,ACCESS
	bra	SysRepeatLoopEnd1
SysRepeatLoop1
;HSerSend(13,comport)
	movlw	13
	movwf	SERDATA,ACCESS
	rcall	HSERSEND264
;HSerSend(10,comport)
	movlw	10
	movwf	SERDATA,ACCESS
	rcall	HSERSEND264
;end Repeat
	decfsz	SysRepeatTemp1,F,ACCESS
	bra	SysRepeatLoop1
SysRepeatLoopEnd1
	return

;********************************************************************************

;Overloaded signature: BYTE:byte:, Source: usart.h (773)
HSERSEND264
;Registers/Bits determined by #samevar at top of library
;if comport = 1 Then
	decf	COMPORT,W,ACCESS
	btfss	STATUS, Z,ACCESS
	bra	ENDIF15
;USART_TX_BLOCKING
;Wait While TXIF = Off
SysWaitLoop2
	banksel	PIR3
	btfss	PIR3,U1TXIF,BANKED
	bra	SysWaitLoop2
;ensure any previous operation has completed
;Wait until TRMT = 1
SysWaitLoop3
	banksel	U1ERRIR
	btfss	U1ERRIR,TXMTIF,BANKED
	bra	SysWaitLoop3
;Write the data byte to the USART.
;Sets register to value of SerData - where register could be TXREG or TXREG1 or U1TXB set via the #samevar
;TXREG = SerData
	movffl	SERDATA,U1TXB
;Add USART_DELAY after the byte is sent by the USART module
;Wait USART_DELAY
	movlw	1
	movwf	SysWaitTempMS,ACCESS
	clrf	SysWaitTempMS_H,ACCESS
	banksel	0
	rcall	Delay_MS
;end if
ENDIF15
	return

;********************************************************************************

;Source: HWI2C2_Discovery_for_18F25K42.gcb (31)
INITPPS
;Module: I2C2
;I2C2SCLPPS = 0x0009    'RB1 > SCL2
	movlw	9
	banksel	I2C2SCLPPS
	movwf	I2C2SCLPPS,BANKED
;RB1PPS = 0x0023    'SCL2 > RB1 (bi-directional)
	movlw	35
	movwf	RB1PPS,BANKED
;I2C2SDAPPS = 0x000A    'RB2 > SDA2
	movlw	10
	movwf	I2C2SDAPPS,BANKED
;RB2PPS = 0x0024    'SDA2 > RB2 (bi-directional)
	movlw	36
	movwf	RB2PPS,BANKED
;Module: I2C2 extra settings
;This is a dedicated PIC I2C module
;The clock speed is 125kHz by default (not 100kHz/400kHz)
;See the HWI2C section of the Help, or refer to the chip specific datasheet,  for how to change the clock speed to the desired frequency
;Dir HI2C2_CLOCK out    'Set I2C pin as output
	bcf	TRISB,1,ACCESS
;RB1I2C_TH0=1    'Set the I2C level for the pin
	bsf	RB1I2C,RB1I2C_TH0,BANKED
;ODCB1=1    'Set pin as open drain output
	bsf	ODCONB,ODCB1,BANKED
;Dir HI2C2_DATA out    'Set I2C pin as output
	bcf	TRISB,2,ACCESS
;RB2I2C_TH0=1    'Set the I2C level for the pin
	bsf	RB2I2C,RB2I2C_TH0,BANKED
;ODCB2=1    'Set pin as open drain output
	bsf	ODCONB,ODCB2,BANKED
;Module: UART pin directions
;Dir PORTC.6 Out    ' Make TX1 pin an output
	bcf	TRISC,6,ACCESS
;Module: UART1
;RC6PPS = 0x0013    'TX1
	movlw	19
	movwf	RC6PPS,BANKED
	banksel	0
	return

;********************************************************************************

;Source: system.h (115)
INITSYS
;asm showdebug This code block sets the internal oscillator to ChipMHz
;asm showdebug Default settings for microcontrollers with _OSCCON1_
;Default OSCCON1 typically, NOSC HFINTOSC; NDIV 1 - Common as this simply sets the HFINTOSC
;asm showdebug OSCCON type is default
;OSCCON1 = 0x60
	movlw	96
	banksel	OSCCON1
	movwf	OSCCON1,BANKED
;Default value typically, CSWHOLD may proceed; SOSCPWR Low power
;OSCCON3 = 0x00
	clrf	OSCCON3,BANKED
;Default value typically, MFOEN disabled; LFOEN disabled; ADOEN disabled; SOSCEN disabled; EXTOEN disabled; HFOEN disabled
;OSCEN = 0x00
	clrf	OSCEN,BANKED
;Default value
;OSCTUNE = 0x00
	clrf	OSCTUNE,BANKED
;asm showdebug The MCU is a chip family ChipFamily
;Section supports many MCUs, 18FxxK40, 18FxxK42 etc that have NDIV3 bit
;asm showdebug OSCCON type is 101
;Clear NDIV3:0
;NDIV3 = 0
	bcf	OSCCON1,NDIV3,BANKED
;NDIV2 = 0
	bcf	OSCCON1,NDIV2,BANKED
;NDIV1 = 0
	bcf	OSCCON1,NDIV1,BANKED
;NDIV0 = 0
	bcf	OSCCON1,NDIV0,BANKED
;OSCFRQ = 0b00001000  '64mhz
	movlw	8
	movwf	OSCFRQ,BANKED
;asm showdebug _Complete_the_chip_setup_of_BSR,ADCs,ANSEL_and_other_key_setup_registers_or_register_bits
;Clear BSR on ChipFamily16 MCUs
;BSR = 0
	clrf	BSR,ACCESS
;Clear TBLPTRU on MCUs with this bit as this must be zero
;TBLPTRU = 0
	clrf	TBLPTRU,ACCESS
;Ensure all ports are set for digital I/O and, turn off A/D
;SET ADFM OFF
	banksel	ADCON0
	bcf	ADCON0,ADFM0,BANKED
;Switch off A/D Var(ADCON0)
;SET ADCON0.ADON OFF
	bcf	ADCON0,ADON,BANKED
;Commence clearing any ANSELx variants in the part, if the ANSEL regsier/bit exists
;ANSELA = 0
	banksel	ANSELA
	clrf	ANSELA,BANKED
;ANSELB = 0
	clrf	ANSELB,BANKED
;ANSELC = 0
	clrf	ANSELC,BANKED
;End  clearing ANSEL
;Set comparator register bits for many MCUs with register CM2CON0
;C2EN = 0
	banksel	CM2CON0
	bcf	CM2CON0,C2EN,BANKED
;C1EN = 0
	bcf	CM1CON0,C1EN,BANKED
;Turn off all ports
;PORTA = 0
	clrf	PORTA,ACCESS
;PORTB = 0
	clrf	PORTB,ACCESS
;PORTC = 0
	clrf	PORTC,ACCESS
;PORTE = 0
	clrf	PORTE,ACCESS
	banksel	0
	return

;********************************************************************************

;Source: usart.h (468)
INITUSART
;Set the default value for comport
;comport = 1
	movlw	1
	movwf	COMPORT,ACCESS
;Set baud rate for for 18fxxK42/K83 series UART
;U1BRGH=SPBRGH_TEMP
	movlw	6
	banksel	U1BRGH
	movwf	U1BRGH,BANKED
;U1BRGL=SPBRGL_TEMP
	movlw	129
	movwf	U1BRGL,BANKED
;U1BRGS = BRGS1_SCRIPT
	bsf	U1CON0,U1BRGS,BANKED
;U1TXEN=1   'Enable TX1
	bsf	U1CON0,U1TXEN,BANKED
;U1RXEN=1   'Enable RX1
	bsf	U1CON0,U1RXEN,BANKED
;ON_U1CON1=1 'Enable USART1
	bsf	U1CON1,ON_U1CON1,BANKED
	banksel	0
	return

;********************************************************************************

;Source: hwi2c2.h (709)
SI2C2DISCOVERY
;HI2C2CON1 = HI2C2CON1Default
	movff	HI2C2CON1DEFAULT,HI2C2CON1
;I2C2CON2 = I2C2CON2Default
	movlw	33
	banksel	I2C2CON2
	movwf	I2C2CON2,BANKED
;I2C2CLK =  I2C2CLOCKSOURCE
	movlw	3
	movwf	I2C2CLK,BANKED
;I2C2CON0 = I2C2CON0Default
	movlw	4
	movwf	I2C2CON0,BANKED
;I2C2PIR = 0    ;Clear all the error flags
	clrf	I2C2PIR,BANKED
;I2C2CON0.EN=1
	bsf	I2C2CON0,EN,BANKED
;Commence I2C protocol
;I2C2CON2.ACNT = 0
	bcf	I2C2CON2,ACNT,BANKED
;I2C2CON2.ABD=0
	bcf	I2C2CON2,ABD,BANKED
;I2C2CON0.MDR=1
	bsf	I2C2CON0,MDR,BANKED
;I2C2CON1.7=0
	bcf	I2C2CON1,7,BANKED
;I2C2ADB1= address
	movffl	ADDRESS,I2C2ADB1
;I2C2CON0.S=1
	bsf	I2C2CON0,S,BANKED
;wait while I2C2STAT1.TXBE <> 1
SysWaitLoop1
	btfss	I2C2STAT1,TXBE,BANKED
	bra	SysWaitLoop1
;Set the byte count to 1, place outbyte in register, and wait for hardware state machine
;I2C2CNT = 1
	movlw	1
	movwf	I2C2CNT,BANKED
;I2C2TXB = 0 'reg
	clrf	I2C2TXB,BANKED
;I2C2CNT = 1
	movlw	1
	movwf	I2C2CNT,BANKED
;I2C2TXB = 0 'data
	clrf	I2C2TXB,BANKED
;SI2C2Stop
	banksel	0
	rcall	SI2C2STOP
;HI2C2AckpollState = 0
	clrf	HI2C2ACKPOLLSTATE,ACCESS
;HI2C2AckpollState.0 = !I2C2PIR.7
	clrf	SysTemp1,ACCESS
	banksel	I2C2PIR
	btfsc	I2C2PIR,7,BANKED
	incf	SysTemp1,F,ACCESS
	comf	SysTemp1,F,ACCESS
	bcf	HI2C2ACKPOLLSTATE,0,ACCESS
	btfsc	SysTemp1,0,ACCESS
	bsf	HI2C2ACKPOLLSTATE,0,ACCESS
;Reset module
;I2C2CON0.EN=0
	bcf	I2C2CON0,EN,BANKED
;wait 1 ms
	movlw	1
	movwf	SysWaitTempMS,ACCESS
	clrf	SysWaitTempMS_H,ACCESS
	banksel	0
	rcall	Delay_MS
;I2C2CON0.EN=1
	banksel	I2C2CON0
	bsf	I2C2CON0,EN,BANKED
	banksel	0
	return

;********************************************************************************

;Source: hwi2c2.h (391)
SI2C2INIT
;asm showdebug  This method sets the MSSP modules for K42s family chips
;Dir HI2C2_DATA out
	bcf	TRISB,2,ACCESS
;Dir HI2C2_CLOCK out
	bcf	TRISB,1,ACCESS
;I2C2CON1 = I2C2CON1Default
	movlw	128
	banksel	I2C2CON1
	movwf	I2C2CON1,BANKED
;I2C2CON2 = I2C2CON2Default
	movlw	33
	movwf	I2C2CON2,BANKED
;I2C2CLK =  I2C2CLOCKSOURCE
	movlw	3
	movwf	I2C2CLK,BANKED
;I2C2CON0 = I2C2CON0Default
	movlw	4
	movwf	I2C2CON0,BANKED
;I2C2PIR = 0    ;Clear all the error flags
	clrf	I2C2PIR,BANKED
;I2C2ERR = 0
	clrf	I2C2ERR,BANKED
;I2C2CON0.EN=1
	bsf	I2C2CON0,EN,BANKED
;Commence I2C protocol
;I2C2CON2.ACNT = 0
	bcf	I2C2CON2,ACNT,BANKED
;I2C2CON2.ABD=0
	bcf	I2C2CON2,ABD,BANKED
;I2C2CON0.MDR=1
	bsf	I2C2CON0,MDR,BANKED
;Initialise correct state of I2C2 module. Not sure why this is needed but it is. Microchip failed to explain why this is required. But, it is.
;SI2C2Start
	banksel	0
	rcall	SI2C2START
;SI2C2Send ( 0xff )
	setf	I2C2BYTE,ACCESS
	rcall	SI2C2SEND
;SI2C2Stop
	rcall	SI2C2STOP
;HI2C2CurrentMode = 0
	clrf	HI2C2CURRENTMODE,ACCESS
	return

;********************************************************************************

;Source: hwi2c2.h (506)
SI2C2SEND
;asm showdebug  Redirected for K42 family probalby called HI2C2Send
;asm showdebug  This method sets the registers and register bits to send I2C data
;This is now a state Machine to cater for the new approach with the I2C module
;Select Case HI2C2StateMachine
;case 2  'send data
SysSelect1Case1
	movlw	2
	subwf	HI2C2STATEMACHINE,W,ACCESS
	btfss	STATUS, Z,ACCESS
	bra	SysSelect1Case2
;HI2C2WaitMSSPTimeout = 0
	clrf	HI2C2WAITMSSPTIMEOUT,ACCESS
;waits up to 254us then creates error message
;do while HI2C2WaitMSSPTimeout < 255
SysDoLoop_S3
	movlw	255
	subwf	HI2C2WAITMSSPTIMEOUT,W,ACCESS
	btfsc	STATUS, C,ACCESS
	bra	SysDoLoop_E3
;HI2C2WaitMSSPTimeout++
	incf	HI2C2WAITMSSPTIMEOUT,F,ACCESS
;Wait for this event
;if I2C2STAT1.TXBE = 1 then
	banksel	I2C2STAT1
	btfss	I2C2STAT1,TXBE,BANKED
	bra	ELSE18_1
;Set the byte count to 1, place outbyte in register, and wait for hardware state machine
;I2C2CNT = 1
	movlw	1
	movwf	I2C2CNT,BANKED
;I2C2TXB = I2C2Byte
	movffl	I2C2BYTE,I2C2TXB
;SI2C2Wait4Ack
	banksel	0
	rcall	SI2C2WAIT4ACK
;SI2C2wait4MDR
	rcall	SI2C2WAIT4MDR
;exit Sub
	return
;else
	bra	ENDIF18
ELSE18_1
;wait 1 us
	movlw	5
	movwf	DELAYTEMP,ACCESS
DelayUS4
	decfsz	DELAYTEMP,F,ACCESS
	bra	DelayUS4
;end if
ENDIF18
;loop
	bra	SysDoLoop_S3
SysDoLoop_E3
;if HI2C2WaitMSSPTimeout = 255 then HI2C2lastError = HI2C2lastError or I2C2_TXBE_TIMEOUT
	incf	HI2C2WAITMSSPTIMEOUT,W,ACCESS
	btfss	STATUS, Z,ACCESS
	bra	ENDIF19
	movlw	2
	iorwf	HI2C2LASTERROR,F,ACCESS
ENDIF19
;case 1  'A start
	bra	SysSelectEnd1
SysSelect1Case2
	decf	HI2C2STATEMACHINE,W,ACCESS
	btfss	STATUS, Z,ACCESS
	bra	SysSelect1Case3
;Clear the output buffers, set byte count to zero, clear event and place Slave Address in register
;I2C2STAT1.CLRBF = 1
	banksel	I2C2STAT1
	bsf	I2C2STAT1,CLRBF,BANKED
;I2C2CNT = 0
	clrf	I2C2CNT,BANKED
;I2C2PIR.SCIF = 0
	bcf	I2C2PIR,SCIF,BANKED
;I2C2ADB1 = I2C2Byte
	movffl	I2C2BYTE,I2C2ADB1
;HI2C2WaitMSSPTimeout = 0
	clrf	HI2C2WAITMSSPTIMEOUT,ACCESS
;waits up to 254us then creates error message
;do while HI2C2WaitMSSPTimeout < 255
SysDoLoop_S4
	movlw	255
	subwf	HI2C2WAITMSSPTIMEOUT,W,ACCESS
	btfsc	STATUS, C,ACCESS
	bra	SysDoLoop_E4
;HI2C2WaitMSSPTimeout++
	incf	HI2C2WAITMSSPTIMEOUT,F,ACCESS
;Wait for this event
;if I2C2PIR.SCIF = 1 then
	btfss	I2C2PIR,SCIF,BANKED
	bra	ELSE20_1
;HI2C2StateMachine = 2  'Set state Machine to send data
	movlw	2
	movwf	HI2C2STATEMACHINE,ACCESS
;HI2C2AckPollState = I2C2CON1.5
	clrf	HI2C2ACKPOLLSTATE,ACCESS
	btfsc	I2C2CON1,5,BANKED
	incf	HI2C2ACKPOLLSTATE,F,ACCESS
;exit Sub
	banksel	0
	return
;else
	bra	ENDIF20
ELSE20_1
;Set to start
;I2C2CON0.S = 1
	bsf	I2C2CON0,S,BANKED
;wait 1 us
	movlw	5
	movwf	DELAYTEMP,ACCESS
DelayUS5
	decfsz	DELAYTEMP,F,ACCESS
	bra	DelayUS5
;end if
ENDIF20
;loop
	bra	SysDoLoop_S4
SysDoLoop_E4
;if HI2C2WaitMSSPTimeout = 255 then HI2C2lastError = HI2C2lastError or I2C2_START_TIMEOUT
	incf	HI2C2WAITMSSPTIMEOUT,W,ACCESS
	btfss	STATUS, Z,ACCESS
	bra	ENDIF21
	movlw	4
	iorwf	HI2C2LASTERROR,F,ACCESS
ENDIF21
;case 3  'A restart
	bra	SysSelectEnd1
SysSelect1Case3
	movlw	3
	subwf	HI2C2STATEMACHINE,W,ACCESS
	btfss	STATUS, Z,ACCESS
	bra	SysSelectEnd1
;wait for hardware machine to settle
;wait while I2C2STAT0.MMA = 1
SysWaitLoop4
	banksel	I2C2STAT0
	btfsc	I2C2STAT0,MMA,BANKED
	bra	SysWaitLoop4
;set count to zero, place Slave address in register and clear event
;I2C2CNT = 0
	clrf	I2C2CNT,BANKED
;I2C2ADB1 = I2C2Byte
	movffl	I2C2BYTE,I2C2ADB1
;I2C2PIR.SCIF = 0
	bcf	I2C2PIR,SCIF,BANKED
;HI2C2WaitMSSPTimeout = 0
	clrf	HI2C2WAITMSSPTIMEOUT,ACCESS
;waits up to 254us then creates error message
;do while HI2C2WaitMSSPTimeout < 255
SysDoLoop_S5
	movlw	255
	subwf	HI2C2WAITMSSPTIMEOUT,W,ACCESS
	btfsc	STATUS, C,ACCESS
	bra	SysDoLoop_E5
;HI2C2WaitMSSPTimeout++
	incf	HI2C2WAITMSSPTIMEOUT,F,ACCESS
;Wait for this event
;if I2C2PIR.SCIF = 1 then
	btfss	I2C2PIR,SCIF,BANKED
	bra	ELSE22_1
;HI2C2StateMachine = 2  'Set state Machine to send data
	movlw	2
	movwf	HI2C2STATEMACHINE,ACCESS
;HI2C2AckPollState = I2C2CON1.5
	clrf	HI2C2ACKPOLLSTATE,ACCESS
	btfsc	I2C2CON1,5,BANKED
	incf	HI2C2ACKPOLLSTATE,F,ACCESS
;exit Sub
	banksel	0
	return
;else
	bra	ENDIF22
ELSE22_1
;Set as Start and Clear Restart
;I2C2CON0.S = 1
	bsf	I2C2CON0,S,BANKED
;I2C2CON0.RSEN=0
	bcf	I2C2CON0,RSEN,BANKED
;wait 1 us
	movlw	5
	movwf	DELAYTEMP,ACCESS
DelayUS6
	decfsz	DELAYTEMP,F,ACCESS
	bra	DelayUS6
;end if
ENDIF22
;loop
	bra	SysDoLoop_S5
SysDoLoop_E5
;if HI2C2WaitMSSPTimeout = 255 then HI2C2lastError = HI2C2lastError or I2C2_RESTART_TIMEOUT
	incf	HI2C2WAITMSSPTIMEOUT,W,ACCESS
	btfss	STATUS, Z,ACCESS
	bra	ENDIF23
	movlw	8
	iorwf	HI2C2LASTERROR,F,ACCESS
ENDIF23
;end select
SysSelectEnd1
	banksel	0
	return

;********************************************************************************

;Source: hwi2c2.h (458)
SI2C2START
;asm showdebug  Redirected for K42 family probalby called HI2C2Start
;asm showdebug  This method sets the registers and register bits to generate the I2C  START signal. Master_mode only.
;HI2C2StateMachine = 1
	movlw	1
	movwf	HI2C2STATEMACHINE,ACCESS
;HI2C2WaitMSSPTimeout = false
	clrf	HI2C2WAITMSSPTIMEOUT,ACCESS
;Clear the error state variable
;HI2C2lastError = I2C2_GOOD
	clrf	HI2C2LASTERROR,ACCESS
	return

;********************************************************************************

;Source: hwi2c2.h (477)
SI2C2STOP
;asm showdebug  Redirected for K42 family probalby called HI2C2Stop
;asm showdebug  This method sets the registers and register bits to generate the I2C  STOP signal
;Waits up to 254us then set the error state
;HI2C2StateMachine = 0
	clrf	HI2C2STATEMACHINE,ACCESS
;HI2C2WaitMSSPTimeout = 0
	clrf	HI2C2WAITMSSPTIMEOUT,ACCESS
;do while HI2C2WaitMSSPTimeout < 255
SysDoLoop_S2
	movlw	255
	subwf	HI2C2WAITMSSPTIMEOUT,W,ACCESS
	btfsc	STATUS, C,ACCESS
	bra	SysDoLoop_E2
;HI2C2WaitMSSPTimeout++
	incf	HI2C2WAITMSSPTIMEOUT,F,ACCESS
;Wait till this event
;if I2C2PIR.PCIF = 1 then
	banksel	I2C2PIR
	btfss	I2C2PIR,PCIF,BANKED
	bra	ELSE16_1
;SI2C2wait4Stop
	banksel	0
	rcall	SI2C2WAIT4STOP
;TSCL wait, part of the specificiation of the I2C Module
;wait HI2C2ITSCLWaitPeriod us
	movlw	1
	movwf	DELAYTEMP2,ACCESS
DelayUSO1
	clrf	DELAYTEMP,ACCESS
DelayUS1
	decfsz	DELAYTEMP,F,ACCESS
	bra	DelayUS1
	decfsz	DELAYTEMP2,F,ACCESS
	bra	DelayUSO1
	movlw	116
	movwf	DELAYTEMP,ACCESS
DelayUS2
	decfsz	DELAYTEMP,F,ACCESS
	bra	DelayUS2
;exit sub
	return
;else
	bra	ENDIF16
ELSE16_1
;wait 1 us
	movlw	5
	movwf	DELAYTEMP,ACCESS
DelayUS3
	decfsz	DELAYTEMP,F,ACCESS
	bra	DelayUS3
;end if
ENDIF16
;loop
	bra	SysDoLoop_S2
SysDoLoop_E2
;if HI2C2WaitMSSPTimeout = 255 then HI2C2lastError = HI2C2lastError or I2C2_STOP_TIMEOUT
	incf	HI2C2WAITMSSPTIMEOUT,W,ACCESS
	btfss	STATUS, Z,ACCESS
	bra	ENDIF17
	movlw	128
	iorwf	HI2C2LASTERROR,F,ACCESS
ENDIF17
	banksel	0
	return

;********************************************************************************

;Source: hwi2c2.h (638)
SI2C2WAIT4ACK
;HI2C2WaitMSSPTimeout = 0
	clrf	HI2C2WAITMSSPTIMEOUT,ACCESS
;waits up to 254us then creates error message
;do while HI2C2WaitMSSPTimeout < 255
SysDoLoop_S6
	movlw	255
	subwf	HI2C2WAITMSSPTIMEOUT,W,ACCESS
	btfsc	STATUS, C,ACCESS
	bra	SysDoLoop_E6
;HI2C2WaitMSSPTimeout++
	incf	HI2C2WAITMSSPTIMEOUT,F,ACCESS
;Wait for this event
;if I2C2CON1.ACKSTAT = 0 then
	banksel	I2C2CON1
	btfsc	I2C2CON1,ACKSTAT,BANKED
	bra	ELSE26_1
;Set status
;HI2C2AckPollState = I2C2CON1.ACKSTAT
	clrf	HI2C2ACKPOLLSTATE,ACCESS
	btfsc	I2C2CON1,ACKSTAT,BANKED
	incf	HI2C2ACKPOLLSTATE,F,ACCESS
;exit sub
	banksel	0
	return
;else
	bra	ENDIF26
ELSE26_1
;wait 1 us
	movlw	5
	movwf	DELAYTEMP,ACCESS
DelayUS7
	decfsz	DELAYTEMP,F,ACCESS
	bra	DelayUS7
;end if
ENDIF26
;loop
	bra	SysDoLoop_S6
SysDoLoop_E6
;if HI2C2WaitMSSPTimeout = 255 then HI2C2lastError = HI2C2lastError or I2C2_ACK_TIMEOUT
	incf	HI2C2WAITMSSPTIMEOUT,W,ACCESS
	btfss	STATUS, Z,ACCESS
	bra	ENDIF27
	movlw	32
	iorwf	HI2C2LASTERROR,F,ACCESS
ENDIF27
;HI2C2WaitMSSPTimeout is now TRUE = 255
	banksel	0
	return

;********************************************************************************

;Source: hwi2c2.h (663)
SI2C2WAIT4MDR
;HI2C2WaitMSSPTimeout = 0
	clrf	HI2C2WAITMSSPTIMEOUT,ACCESS
;waits up to 254us then creates error message
;do while HI2C2WaitMSSPTimeout < 255
SysDoLoop_S7
	movlw	255
	subwf	HI2C2WAITMSSPTIMEOUT,W,ACCESS
	btfsc	STATUS, C,ACCESS
	bra	SysDoLoop_E7
;HI2C2WaitMSSPTimeout++
	incf	HI2C2WAITMSSPTIMEOUT,F,ACCESS
;wait for this event
;if I2C2CON0.MDR = 0 then
	banksel	I2C2CON0
	btfsc	I2C2CON0,MDR,BANKED
	bra	ELSE29_1
;exit sub
	banksel	0
	return
;else
	bra	ENDIF29
ELSE29_1
;wait 1 us
	movlw	5
	movwf	DELAYTEMP,ACCESS
DelayUS8
	decfsz	DELAYTEMP,F,ACCESS
	bra	DelayUS8
;end if
ENDIF29
;loop
	bra	SysDoLoop_S7
SysDoLoop_E7
;if HI2C2WaitMSSPTimeout = 255 then HI2C2lastError = HI2C2lastError or I2C2_MDR_TIMEOUT
	incf	HI2C2WAITMSSPTIMEOUT,W,ACCESS
	btfss	STATUS, Z,ACCESS
	bra	ENDIF30
	movlw	64
	iorwf	HI2C2LASTERROR,F,ACCESS
ENDIF30
;HI2C2WaitMSSPTimeout is now TRUE = 255
	banksel	0
	return

;********************************************************************************

;Source: hwi2c2.h (686)
SI2C2WAIT4STOP
;HI2C2WaitMSSPTimeout = 0
	clrf	HI2C2WAITMSSPTIMEOUT,ACCESS
;waits up to 254us then creates error message
;do while HI2C2WaitMSSPTimeout < 255
SysDoLoop_S8
	movlw	255
	subwf	HI2C2WAITMSSPTIMEOUT,W,ACCESS
	btfsc	STATUS, C,ACCESS
	bra	SysDoLoop_E8
;HI2C2WaitMSSPTimeout++
	incf	HI2C2WAITMSSPTIMEOUT,F,ACCESS
;Wait for this event
;if I2C2PIR.PCIF = 1 then
	banksel	I2C2PIR
	btfss	I2C2PIR,PCIF,BANKED
	bra	ELSE31_1
;exit sub
	banksel	0
	return
;else
	bra	ENDIF31
ELSE31_1
;wait 1 us
	movlw	5
	movwf	DELAYTEMP,ACCESS
DelayUS9
	decfsz	DELAYTEMP,F,ACCESS
	bra	DelayUS9
;end if
ENDIF31
;loop
	bra	SysDoLoop_S8
SysDoLoop_E8
;if HI2C2WaitMSSPTimeout = 255 then HI2C2lastError = HI2C2lastError or I2C2_STOP_TIMEOUT
	incf	HI2C2WAITMSSPTIMEOUT,W,ACCESS
	btfss	STATUS, Z,ACCESS
	bra	ENDIF32
	movlw	128
	iorwf	HI2C2LASTERROR,F,ACCESS
ENDIF32
;HI2C2WaitMSSPTimeout is now TRUE = 255
	banksel	0
	return

;********************************************************************************

;Source: system.h (2455)
SYSDIVSUB
;dim SysByteTempA as byte
;dim SysByteTempB as byte
;dim SysByteTempX as byte
;Check for div/0
;movf SysByteTempB, F
	movf	SYSBYTETEMPB, F,ACCESS
;btfsc STATUS, Z
	btfsc	STATUS, Z,ACCESS
;return
	return
;Main calc routine
;SysByteTempX = 0
	clrf	SYSBYTETEMPX,ACCESS
;SysDivLoop = 8
	movlw	8
	movwf	SYSDIVLOOP,ACCESS
SYSDIV8START
;bcf STATUS, C
	bcf	STATUS, C,ACCESS
;rlf SysByteTempA, F
	rlcf	SYSBYTETEMPA, F,ACCESS
;rlf SysByteTempX, F
	rlcf	SYSBYTETEMPX, F,ACCESS
;movf SysByteTempB, W
	movf	SYSBYTETEMPB, W,ACCESS
;subwf SysByteTempX, F
	subwf	SYSBYTETEMPX, F,ACCESS
;bsf SysByteTempA, 0
	bsf	SYSBYTETEMPA, 0,ACCESS
;btfsc STATUS, C
	btfsc	STATUS, C,ACCESS
;goto Div8NotNeg
	bra	DIV8NOTNEG
;bcf SysByteTempA, 0
	bcf	SYSBYTETEMPA, 0,ACCESS
;movf SysByteTempB, W
	movf	SYSBYTETEMPB, W,ACCESS
;addwf SysByteTempX, F
	addwf	SYSBYTETEMPX, F,ACCESS
DIV8NOTNEG
;decfsz SysDivLoop, F
	decfsz	SYSDIVLOOP, F,ACCESS
;goto SysDiv8Start
	bra	SYSDIV8START
	return

;********************************************************************************

;Source: system.h (1306)
SYSREADSTRING
;Dim SysCalcTempA As Byte
;Dim SysStringLength As Byte
;Get length
;TBLRD*+
	tblrd*+
;movff TABLAT,SysCalcTempA
	movffl	TABLAT,SYSCALCTEMPA
;movff TABLAT,INDF1
	movffl	TABLAT,INDF1
;goto SysStringReadCheck
	bra	SYSSTRINGREADCHECK
SYSREADSTRINGPART
;TBLRD*+
	tblrd*+
;movf TABLAT, W
	movf	TABLAT, W,ACCESS
;movwf SysCalcTempA
	movwf	SYSCALCTEMPA,ACCESS
;addwf SysStringLength,F
	addwf	SYSSTRINGLENGTH,F,ACCESS
;Check length
SYSSTRINGREADCHECK
;If length is 0, exit
;movf SysCalcTempA,F
	movf	SYSCALCTEMPA,F,ACCESS
;btfsc STATUS,Z
	btfsc	STATUS,Z,ACCESS
;return
	return
;Copy
SYSSTRINGREAD
;Copy char
;TBLRD*+
	tblrd*+
;movff TABLAT,PREINC1
	movffl	TABLAT,PREINC1
;decfsz SysCalcTempA, F
	decfsz	SYSCALCTEMPA, F,ACCESS
;goto SysStringRead
	bra	SYSSTRINGREAD
	return

;********************************************************************************

SysStringTables

StringTable1
	db	22,45,45,45,32,72,97,114,100,119,97,114,101,32,73,50,67,50,32,45,45,45,32


StringTable2
	db	3,32,32,32


StringTable3
	db	1,32


StringTable4
	db	2,45,45


StringTable5
	db	2,33,32


StringTable6
	db	13,69,110,100,32,111,102,32,83,101,97,114,99,104


StringTable7
	db	30,84,101,115,116,32,87,105,108,108,32,82,101,115,116,97,114,116,32,105,110,32
	db	53,32,83,101,99,111,110,100,115


;********************************************************************************


 END
